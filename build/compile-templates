#!/usr/bin/env node 

const glob = require("glob");
const { dirname, relative, join, basename, extname } = require("path");
const { writeFileSync, mkdirSync } = require("fs");

const camelCase = require("camelcase");

const { renderFile } = require("pug");
const { decode } = require("ent");
const { Parser } = require("htmlparser2");
const beautify = require("js-beautify").js;

//
//

const indir = "src/pug";
const outdir = "generated/ts/view/template";
const selector = "**/*.pug";

//
//

class Element {
  constructor(parent = undefined) {
    this.parent = parent;
    
    this.children = [];
  }
  
  appendToString(string) {
    this.children.push(string);
  }
  
  toString() {
    let string = "";
    let needsComma = false;
    for (let child of this.children) {
      if (needsComma) {
        string += ",";
      }
      
      string += child;
      needsComma = true;
    }
    return string;
  }
}

const write = ( path, data ) => {
  mkdirSync(dirname(path), { 
    recursive: true 
  });
  
  writeFileSync(path, data);
}

const compileTemplate = ( path ) => {
  const relativePath = relative(indir, path);
  const templateName = basename(relativePath, extname(relativePath));
  
  const className = camelCase(templateName, { pascalCase: true }) + "Template";
  const outpath = join(outdir, dirname(relativePath), templateName + ".ts");
  
  const html = renderFile(path).trim();
  
  let refdElements = "";
  
  const rootElement = new Element();
  let currentElement = rootElement;
  let elementStack = [];
  const parser = new Parser({
    onopentag: (name, attrs) => {
        currentElement = new Element(currentElement);
        currentElement.name = name;
        currentElement.attrs = attrs;
    },
    ontext: (text) => {
      const string = JSON.stringify(decode(text));
      currentElement.appendToString(`t(${string})`);
    },
    oncomment: (text) => {
      currentElement.string += `/* ${text} */`; 
    },
    onclosetag: (tagname) => {
      const elementNameString = JSON.stringify(currentElement.name);
  
      let elementRefString = "undefined";
      let elementAttrsElement = new Element();
  
      for (let key in currentElement.attrs) {
        let value = currentElement.attrs[key];
        if (key === "ref") {
          elementRefString = value;
        } else {
          elementAttrsElement.appendToString(`new Attribute(${JSON.stringify(key)}, ${JSON.stringify(value)})`);
        }
      }
      
      const elementAttrsString = `[${elementAttrsElement.toString()}]`;
  
      const elementContent = currentElement.toString();
  
      // pop tree
      currentElement = currentElement.parent;
  
      const string = `h(${elementNameString}, ${elementAttrsString}, [${elementContent}])`;
  
      if (elementRefString !== "undefined") {
        refdElements += `public ${elementRefString}: HTMLElement = ${string};`;
        currentElement.appendToString(`this.${elementRefString}`);
      } else {
        currentElement.appendToString(string);
      }
    }
  }, {
    decodeEntities: true, 
    xmlMode: true
  });
  parser.write(html);
  parser.end();
  
  let appendChildrenString = "";
  
  let once = true;
  for (let child of rootElement.children) {
    if (!once) {
      appendChildrenString += "\n";
    }
    appendChildrenString += `      parent.appendChild(${child});`;
    once = false;
  }
  
  const func = `class ${className} extends ViewBase {
  ${refdElements}
  
  constructor(parent: HTMLElement) {
    super(parent);
    
    const appendChildren = () => {
${appendChildrenString}
    };
    
    this.queue.push(appendChildren);
  }
  
  public loop() {
    super.loop();
  }
}`;
  
  code = `import { Attribute, h, t } from "view/render";
import { ViewBase } from "view/base";
export default ${func}`;
  
  code = beautify(code, { 
    indent_size: 2, 
    space_in_empty_paren: true 
  });
  
  write(outpath, code);
}

glob.sync(join(indir, selector)).forEach(compileTemplate);
